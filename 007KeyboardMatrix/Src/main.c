/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body - 4x4 Keypad Scanner
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdio.h>
#include <stdint.h>
#include "main.h"

#define GPIO_MODE_INPUT    0U
#define GPIO_MODE_OUTPUT   1U
#define GPIO_PUPDR_PULLUP  1U
#define HIGH_STATE         1U
#define LOW_STATE          0U

#define SCAN_DELAY_CYCLES      8000U
#define DEBOUNCE_DELAY_CYCLES  160000U
#define RELEASE_POLL_CYCLES    8000U
#define CLOCK_SETTLE_CYCLES    1000U

// 4x4 matrix keyboard
static const char keypad_map[4][4] = {
    {'1', '2', '3', 'A'},
    {'4', '5', '6', 'B'},
    {'7', '8', '9', 'C'},
    {'*', '0', '#', 'D'}
};


static inline void row_all_high(volatile GPIOX_BSRR_t *bsrrB, volatile GPIOX_BSRR_t *bsrrC)
{
    bsrrB->set_8 = HIGH_STATE;
    bsrrC->set_6 = HIGH_STATE;
    bsrrC->set_8 = HIGH_STATE;
    bsrrC->set_9 = HIGH_STATE;
}

static inline void row_set_low(uint8_t row, volatile GPIOX_BSRR_t *bsrrB, volatile GPIOX_BSRR_t *bsrrC)
{
    switch(row)
    {
    case 0:
        bsrrC->rst_9 = HIGH_STATE;
        break;
    case 1:
        bsrrC->rst_8 = HIGH_STATE;
        break;
    case 2:
        bsrrC->rst_6 = HIGH_STATE;
        break;
    case 3:
        bsrrB->rst_8 = HIGH_STATE;
        break;
    default:
        break;
    }
}

static inline int read_col_index(volatile GPIOX_IDR_t *idrA, volatile GPIOX_IDR_t *idrB, volatile GPIOX_IDR_t *idrC)
{
    if((idrA->pin_5) == LOW_STATE) return COL_4;
    if((idrA->pin_12) == LOW_STATE) return COL_3;
    if((idrB->pin_9) == LOW_STATE) return COL_2;
    if((idrC->pin_5) == LOW_STATE) return COL_1;
    return COL_NONE;
}


static inline void delay_cycles(volatile uint32_t cycles)
{
    for(volatile uint32_t i = 0; i < cycles; i++)
        __asm volatile("nop");
}

int main(void){

    RCC_AHB1ENR_t volatile *const pClock_en = (volatile RCC_AHB1ENR_t*)0x40023830;

    // GPIO Mode Registers
    GPIOX_MODER_t volatile *const pGpioA_Mode = (volatile GPIOX_MODER_t*)0x40020000;
    GPIOX_MODER_t volatile *const pGpioB_Mode = (volatile GPIOX_MODER_t*)0x40020400;
    GPIOX_MODER_t volatile *const pGpioC_Mode = (volatile GPIOX_MODER_t*)0x40020800;

    // GPIO Output Control (BSRR)
    GPIOX_BSRR_t volatile *const pGpioB_BSRR = (volatile GPIOX_BSRR_t*)0x40020418;
    GPIOX_BSRR_t volatile *const pGpioC_BSRR = (volatile GPIOX_BSRR_t*)0x40020818;

    // GPIO Input Data Registers
    GPIOX_IDR_t volatile *const pGpioA_In = (volatile GPIOX_IDR_t*)0x40020010;
    GPIOX_IDR_t volatile *const pGpioB_In = (volatile GPIOX_IDR_t*)0x40020410;
    GPIOX_IDR_t volatile *const pGpioC_In = (volatile GPIOX_IDR_t*)0x40020810;

    // GPIO Pull-up/Pull-down Registers
    GPIOX_PUPDR_t volatile *const pGpioA_PUPDR = (volatile GPIOX_PUPDR_t*)0x4002000C;
    GPIOX_PUPDR_t volatile *const pGpioB_PUPDR = (volatile GPIOX_PUPDR_t*)0x4002040C;
    GPIOX_PUPDR_t volatile *const pGpioC_PUPDR = (volatile GPIOX_PUPDR_t*)0x4002080C;

    // ========== Clock Configuration ==========
    pClock_en->gpioA_EN = 1;
    pClock_en->gpioB_EN = 1;
    pClock_en->gpioC_EN = 1;

    // Wait for clock to stabilize
    delay_cycles(CLOCK_SETTLE_CYCLES);

    pGpioA_Mode->pin_5 = GPIO_MODE_INPUT;   // Column 4
    pGpioA_Mode->pin_12 = GPIO_MODE_INPUT;  // Column 3
    pGpioB_Mode->pin_9 = GPIO_MODE_INPUT;   // Column 2
    pGpioC_Mode->pin_5 = GPIO_MODE_INPUT;   // Column 1

    pGpioB_Mode->pin_8 = GPIO_MODE_OUTPUT;  // Row 4
    pGpioC_Mode->pin_6 = GPIO_MODE_OUTPUT;  // Row 3
    pGpioC_Mode->pin_8 = GPIO_MODE_OUTPUT;  // Row 2
    pGpioC_Mode->pin_9 = GPIO_MODE_OUTPUT;  // Row 1

    pGpioA_PUPDR->pin_5 = GPIO_PUPDR_PULLUP;
    pGpioA_PUPDR->pin_12 = GPIO_PUPDR_PULLUP;
    pGpioB_PUPDR->pin_9 = GPIO_PUPDR_PULLUP;
    pGpioC_PUPDR->pin_5 = GPIO_PUPDR_PULLUP;

    row_all_high(pGpioB_BSRR, pGpioC_BSRR);

    printf("Scan started.\r\n");

    while (1)
    {
        for (uint8_t row = 0; row < 4; row++)
        {

            row_all_high(pGpioB_BSRR, pGpioC_BSRR);
            row_set_low(row, pGpioB_BSRR, pGpioC_BSRR);

            delay_cycles(SCAN_DELAY_CYCLES);

            int column = read_col_index(pGpioA_In, pGpioB_In, pGpioC_In);

            if (column != COL_NONE)
            {
                delay_cycles(DEBOUNCE_DELAY_CYCLES);

                if (read_col_index(pGpioA_In, pGpioB_In, pGpioC_In) == column)
                {
                    char key = keypad_map[row][column - 1];
                    printf("Key pressed: '%c' (row=%u, col=%d)\r\n", key, row, column);

                    while (read_col_index(pGpioA_In, pGpioB_In, pGpioC_In) != COL_NONE)
                    {
                        delay_cycles(RELEASE_POLL_CYCLES);
                    }

                    row_all_high(pGpioB_BSRR, pGpioC_BSRR);
                    break;
                }
            }
        }

        row_all_high(pGpioB_BSRR, pGpioC_BSRR);
    }
}
